TIM1 + DMA2 → GPIOC->ODR (STM32F401)
=============================================

Описание
--------
Проект демонстрирует использование таймера TIM1 совместно с DMA2 Stream5 для автоматической записи данных из массива в регистр GPIOC->ODR.  
Таймер работает на частоте 2 Гц (событие UPDATE каждые 0.5 секунды).  
Каждое событие UPDATE вызывает DMA, который переносит очередное значение из массива `data[]` в GPIOC->ODR.  
В результате светодиод на PC13 мигает полностью аппаратно, без участия CPU.

----------------------------------------------------------

Частота таймера
---------------
- Тактовая частота шины APB2 = 84 МГц.  
- Таймер TIM1 получает её напрямую.  
- Настройки: Prescaler = 47999, Period = 499.  
- В результате частота события UPDATE ≈ 2 Гц.  
- То есть каждые 0.5 секунды таймер генерирует запрос DMA.

----------------------------------------------------------

Логика работы DMA
-----------------
1. Таймер TIM1 генерирует событие UPDATE.  
2. Контроллер DMA получает запрос.  
3. DMA выполняет одну передачу: берёт элемент из массива `data[]` и пишет его в `GPIOC->ODR`.  
4. Если `MemInc = DISABLE`, DMA всегда берёт первый элемент массива (даже если массив длиннее).  
5. Если `MemInc = ENABLE`, DMA идёт по массиву:
   - первый UPDATE → `data[0]`  
   - второй UPDATE → `data[1]`  
   - и так далее.  
6. В режиме NORMAL DMA выполняет передачу всего массива один раз и останавливается.  
7. В режиме CIRCULAR DMA после конца массива возвращает указатель на начало и продолжает работать по кругу.

----------------------------------------------------------

Важно понимать
--------------
- DMA не работает сам по себе на тактовой частоте.  
- Он активируется только по событию таймера (UPDATE).  
- Каждое событие вызывает одну передачу.  
- В режиме NORMAL после передачи всего массива DMA отключается.  
- В режиме CIRCULAR DMA не отключается, а возвращается к первому элементу массива и продолжает цикл.  

----------------------------------------------------------

Пример массива
--------------
uint32_t data[] = {0xFFFF, 0x0000};

- При первом UPDATE в ODR пишется `0xFFFF` → все биты GPIOC = 1 → LED выключен (активный LOW).  
- При втором UPDATE в ODR пишется `0x0000` → все биты GPIOC = 0 → LED включён.  
- В режиме CIRCULAR цикл повторяется бесконечно.  

----------------------------------------------------------

Архитектурное ограничение DMA1 vs DMA2
--------------------------------------
Из Reference Manual RM0368 (стр. 169):

"1. The DMA1 controller AHB peripheral port is not connected to the bus matrix like DMA2 controller.  
As a result, only DMA2 streams are able to perform memory-to-memory transfers."

Это означает:
- DMA1 имеет ограниченный доступ к шинам и не поддерживает memory-to-memory режим.  
- DMA2 подключён к полной матрице шин (AHB1, AHB2, APB1, APB2) и может выполнять memory-to-memory передачи.  
- В данном проекте используется TIM1 (APB2), который обслуживается именно DMA2, поэтому связка TIM1 → DMA2 → GPIOC работает корректно.

----------------------------------------------------------

----------------------------------------------------------

Как наглядно увидеть принцип режима NORMAL
---------------------------
Если установить:

hdma_tim1_up.Init.Mode = DMA_NORMAL;

то можно проверить поведение DMA при разной длине массива.

Пример:

uint32_t data[] = {0xFFFF, 0x0, 0xFFFF, 0x0, 0xFFFF, 0x0, 0xFFFF, 0x0, 0xFFFF, 0x0, 0xFFFF, 0x0};

HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_TIM1_Init();

if(HAL_TIM_Base_Start(&htim1) != HAL_OK) Error_Handler();
HAL_DMA_Start(&hdma_tim1_up, (uint32_t)data, (uint32_t)&GPIOC->ODR, 6);
__HAL_TIM_ENABLE_DMA(&htim1, TIM_DMA_UPDATE);

Результат:
- Светодиод моргнёт 4 раза и останется гореть (так как последний элемент массива = 0x0).
- При инициализации GPIO используется `HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);`, поэтому LED стартует во включённом состоянии.

Если изменить длину передачи:

HAL_DMA_Start(&hdma_tim1_up, (uint32_t)data, (uint32_t)&GPIOC->ODR, 4);


то LED моргнёт 3 раза и остановится.

Важно: всегда прописывайте массив `data[]` с нужным количеством элементов, иначе DMA будет читать мусор.
----------------------------------------------------------

Итог
----
Каждое событие UPDATE таймера TIM1 вызывает DMA, который переносит очередное значение из массива в GPIOC->ODR.  
С `MemInc = ENABLE` данные берутся по порядку из массива.  
В режиме NORMAL DMA выполняет передачу один раз и останавливается.  
В режиме CIRCULAR DMA бесконечно повторяет цикл, возвращаясь к первому элементу массива.  
Таким образом, LED мигает аппаратно с частотой таймера, без участия CPU.  
Использование DMA2 гарантирует корректную работу, так как только DMA2 поддерживает полный доступ к шинам и memory-to-memory режим.
