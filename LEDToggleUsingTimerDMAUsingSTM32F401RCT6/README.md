README — Timer + DMA → GPIO Pattern Generator (STM32F401)
==========================================================

Описание
--------
Этот проект демонстрирует использование таймера TIM1 совместно с DMA2 Stream5 для автоматической записи данных в регистр GPIOC->ODR без участия процессора.  
Таймер генерирует событие UPDATE с заданной периодичностью, и каждое такое событие запускает DMA‑передачу.  
DMA циклически записывает два значения (0xFFFF и 0x0000) в регистр ODR, что приводит к миганию светодиода на выводе PC13.

Процесс полностью аппаратный: CPU не участвует в переключении GPIO.

----------------------------------------------------------

Как это работает
----------------

1. Таймер TIM1 настроен на генерацию события UPDATE каждые 0.5 секунды.
2. Для TIM1 включён источник DMA‑запросов по событию UPDATE.
3. DMA2 Stream5 настроен в режиме:
   - направление: память → периферия
   - источник: массив data[]
   - приёмник: GPIOC->ODR
   - размер данных: 32 бита (WORD)
   - режим: CIRCULAR (бесконечный цикл)
4. При каждом UPDATE таймер генерирует DMA‑запрос.
5. DMA выполняет одну передачу: берёт очередное значение из массива и записывает его в GPIOC->ODR.
6. После записи двух элементов DMA возвращается к первому (режим CIRCULAR).
7. Светодиод на PC13 мигает без участия CPU.

----------------------------------------------------------

Почему используются 32‑битные данные
------------------------------------
Регистр GPIOC->ODR является 32‑битным.  
Светодиод на плате Blackpill подключён к выводу PC13, который находится в старшем полуслове регистра.

Если бы использовалась запись BYTE или HALFWORD, DMA изменял бы только младшие биты, и PC13 не менял бы состояние.

Поэтому DMA настроен на WORD‑доступ.

----------------------------------------------------------

Тайминг таймера
----------------
Настройки:

Prescaler = 47999  
Period    = 499  

Частота таймера TIM1:

TIM1 работает от шины APB2.  
APB2 = 84 MHz, но таймеры получают удвоенную частоту: 168 MHz.

168 MHz / 48000 = 3500 Hz  
3500 Hz / 500 = 7 Hz  

Период одного UPDATE ≈ 0.142 секунды.

DMA переключает два значения по кругу, поэтому полный цикл мигания ≈ 0.284 секунды.

----------------------------------------------------------

Последовательность инициализации
--------------------------------

1. Инициализация HAL и системного тактирования.
2. Инициализация GPIOC (PC13 как выход).
3. Инициализация DMA2 Stream5.
4. Инициализация TIM1.
5. Запуск таймера:
   HAL_TIM_Base_Start(&htim1);
6. Запуск DMA:
   HAL_DMA_Start(&hdma_tim1_up, (uint32_t)data, (uint32_t)&GPIOC->ODR, 2);
7. Разрешение DMA‑запросов от TIM1:
   __HAL_TIM_ENABLE_DMA(&htim1, TIM_DMA_UPDATE);

После этого система работает полностью аппаратно.

----------------------------------------------------------

Что делает массив data[]
------------------------

uint16_t data[] = {0xFFFF, 0x0000};

0xFFFF — включает все биты ODR, включая PC13 → LED выключен (активный LOW)  
0x0000 — сбрасывает все биты ODR → LED включён  

DMA чередует эти значения, создавая мигание.

----------------------------------------------------------

Почему не нужны прерывания
--------------------------
DMA работает аппаратно и не требует участия CPU.  
Прерывания DMA используются только для уведомления о завершении передачи, но в режиме CIRCULAR завершения не происходит.

Поэтому IRQ не используются.

----------------------------------------------------------

Итог
----
Проект демонстрирует полностью аппаратный способ генерации паттернов на GPIO с помощью связки TIM1 + DMA2.  
CPU не участвует в переключении пинов, что позволяет экономить энергию и ресурсы процессора.

-----------------------------------------
-----------------------------------------

Если хочешь, могу сделать вторую версию README — Markdown‑формат для GitHub, с диаграммами и подсветкой кода.